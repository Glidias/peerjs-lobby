// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, Lobby, PeerList, duplexEmitter, websocket,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  websocket = require('websocket-stream');

  duplexEmitter = require('duplex-emitter');

  EventEmitter = require('events').EventEmitter;

  /*
  TODO ?
    shared game clock
    dead reckoning/extrapolation
    interpolation
    client side prediction
  */


  Lobby = (function(_super) {
    __extends(Lobby, _super);

    function Lobby() {
      this.peerID = ~~(Math.random() * 10000) + '' + ~~(Math.random() * 10000);
      this.emitter = null;
      this.socket = null;
    }

    Lobby.prototype.create = function(name, maxPlayers, memberCallback) {
      if (maxPlayers == null) {
        maxPlayers = 5;
      }
      this.memberCallback = memberCallback;
      this.emitter || (this.emitter = this._connect());
      return this.emitter.emit('create', this.peerID, name, maxPlayers);
    };

    Lobby.prototype.join = function(name, memberCallback) {
      this.memberCallback = memberCallback;
      this.emitter || (this.emitter = this._connect());
      return this.emitter.emit('join', this.peerID, name);
    };

    Lobby.prototype.start = function() {
      if (!this.emitter) {
        throw new Error('never called create or join');
      }
      return this.emitter.emit('start', this.peerID);
    };

    Lobby.prototype.leave = function() {
      return this.emitter.emit('leave', this.peerID);
    };

    Lobby.prototype._connect = function() {
      var emitter,
        _this = this;
      this.socket = websocket('ws://localhost:8080');
      emitter = duplexEmitter(this.socket);
      emitter.on('lobby_leave', function(players) {
        players = JSON.parse(players);
        return _this.memberCallback('leave', null, players);
      });
      emitter.on('lobby_join', function(name, players) {
        return _this.memberCallback('join', name, players);
      });
      emitter.on('lobby_start', function(gameInfo) {
        var p;
        emitter.emit('connected');
        _this.socket.ws.close();
        _this.emitter = null;
        _this.socket = null;
        return p = new PeerList(_this.peerID, gameInfo, function() {
          return _this.emit('start', p);
        });
      });
      return emitter;
    };

    return Lobby;

  })(EventEmitter);

  PeerList = (function(_super) {
    __extends(PeerList, _super);

    function PeerList(peerID, gameInfo, callback) {
      var p, _i, _len, _ref,
        _this = this;
      this.peerID = peerID;
      this._recv = __bind(this._recv, this);
      this.players = {};
      this.peer = new Peer(this.peerID, {
        host: 'localhost',
        port: 9000
      });
      this.peer.on('connection', function(conn) {
        console.log('received connection from a peer', conn);
        conn.on('data', function(msg) {
          return _this._recv(conn.peer, msg);
        });
        conn.on('error', _this._removePeer);
        conn.on('close', _this._removePeer);
        return _this.players[conn.peer] = {
          name: _this._findPlayerName(conn.peer, gameInfo),
          conn: conn
        };
      });
      this.peer.on('error', function(e) {
        return console.log('peerjs error evt', e);
      });
      this.peer.on('close', function() {
        return console.log('peerjs close evt');
      });
      _ref = gameInfo.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p.peerID !== this.peerID && this.peerID < p.peerID) {
          console.log('connecting to peer', p.peerID);
          this._createPeerConnection(p.peerID, p.name);
        }
      }
      setTimeout(callback, 3000);
    }

    PeerList.prototype.bcast = function(msg) {
      var peerID, player, _ref, _results;
      _ref = this.players;
      _results = [];
      for (peerID in _ref) {
        player = _ref[peerID];
        if (peerID !== this.peerID) {
          console.log('sending to', peerID, msg);
          _results.push(player.conn.send(msg));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PeerList.prototype.leave = function() {
      var _this = this;
      this.bcast('leave');
      return setTimeout(function() {
        var peerID, player, _ref, _results;
        _ref = _this.players;
        _results = [];
        for (peerID in _ref) {
          player = _ref[peerID];
          if (peerID !== _this.peerID) {
            _results.push(player.conn.close());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }, 4000);
    };

    PeerList.prototype._createPeerConnection = function(peerID, name) {
      var conn,
        _this = this;
      conn = this.peer.connect(peerID);
      conn.on('open', function() {
        console.log('successfully connected to peer');
        return _this.players[peerID] = {
          name: name,
          conn: conn
        };
      });
      conn.on('data', function(msg) {
        return _this._recv(peerID, msg);
      });
      conn.on('error', function(er) {
        console.log('peer connection error', er);
        return _this._removePeer();
      });
      return conn.on('close', function() {
        console.log('peer close');
        return _this._removePeer();
      });
    };

    PeerList.prototype._findPlayerName = function(peerID, gameInfo) {
      var player, _i, _len, _ref;
      _ref = gameInfo.players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        player = _ref[_i];
        if (player.peerID === peerID) {
          return player.name;
        }
      }
      return null;
    };

    PeerList.prototype._recv = function(peerID, msg) {
      return this.emit('message', peerID, msg);
    };

    PeerList.prototype._removePeer = function() {
      return this.emit('leave', this.peer);
    };

    return PeerList;

  })(EventEmitter);

  module.exports.PeerList = PeerList;

  module.exports.Lobby = Lobby;

}).call(this);
